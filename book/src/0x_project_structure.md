# Overview

Unlike most other embedded platforms, Espressif supports the Rust standard library. Most notably this means you'll have arbitrary-sized collections like `Vec` or `HashMap` at your disposal, as well as generic heap storage using `Box`. You're also free to spawn new threads, and use synchronization primitives like `Arc` and `Mutex` to safely share data between them.
Still, memory is a scarce resource on embedded systems, and so you need to take care not to run out of it - threads in particular can become rather expensive.

Services like WiFi, HTTP client/server, MQTT, OTA updates, logging etc. are exposed via Espressif's open source IoT Development Framework, [esp-idf](https://github.com/espressif/esp-idf). It is mostly written in C and as such is exposed to Rust in the canonical split crate style: 
- a `sys` crate to provide the actual `unsafe` bindings ([esp-idf-sys](https://github.com/esp-rs/esp-idf-sys))
- a higher level crate offering safe and comfortable Rust abstractions ([esp-idf-svc](https://github.com/esp-rs/esp-idf-svc/))

The final piece of the puzzle is low-level hardware access, which is again provided in a split fashion:
- [esp-idf-hal](https://github.com/esp-rs/esp-idf-hal) implements the hardware-independent [embedded-hal](https://github.com/rust-embedded/embedded-hal) traits like analog/digital conversion, digital I/O pins, or SPI communication - as the name suggests, it also uses `esp-idf` as a foundation
- if direct register manipulation is required, [esp32c3](https://github.com/esp-rs/esp32c3) provides the peripheral access create generated by svd2rust.

TODO: 
- move esp32c3 to advanced? (then: reword "split")
- explain PAC, SVD, svd2rust, ?PAC vs HAL?
- riscv crate - inline asm - change/check when stabilized

# Dependencies

# Directory layout
## Espressif specific
## This course
recommend: workspace (vs. global) - test

if global, delete when changing 4.4 -> 5.0 etc? 