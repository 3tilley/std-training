# MQTT Exercise

## Setup

You can find a prepared project skeleton in `intro/mqtt/exercise`. 

❗️ Similar to the http exercises you need to configure your WiFi credentials in `cfg.toml`, but here you'll also need to add MQTT server details. Check `cfg.toml.example` for required settings.

## Support tools & crates

To send LED commands to the board and also log the sensor values sent by it, a helper client is provided under `intro/mqtt/example_client`. It will send a new random LED color command and also subscribes to the board temperature topic.

The `mqtt_messages` crate (located in `common/lib`) supports handling messages, subscriptions and topics:
### Functions to generate topic strings
- `hello_topic(uuid)` - test topic for initially verifying a successful connection
- `temperature_data_topic(uuid)` - creates a whole "temperature" topic string 
- `cmd_topic_fragment(uuid)` - creates the leading part of a "command" topic (the `a-uuid/command/` part in `a-uuid/command/board_led`)

### Encoding and decoding message payloads


We're going to use a very rudimentary encoding scheme for our data:
- the board temperature `f32` float is converted to four "big endian" bytes using `temp.to_be_bytes()`.
- board LED commands are made of three bytes indicating red, green and blue.
    - `enum Command`: represents all possible commands (here: just `BoardLed`).
    - `RawCommandData` stores the last part of a message topic (e.g. `board_led` in `a-uuid/command/board_led`). It can be converted into a `Command` using `try_from`.

```rust
// temperature
let temperature_data = temp.to_be_bytes() as &[u8]; // board
let decoded_temperature = f32::from_be_bytes(temperature_data); // workstation

// RGB LED command
let raw = RawCommandData {
    path: command,
    data: message.data(),
};

if let Ok(cmd) = Command::try_from(raw) { /* set new color here */ }
```
## Establishing a connection

Connections are managed by an instance of `esp_idf_svc::mqtt::client::EspMqttClient`.
It is constructed using
- a broker URL which in turn contains credentials, if necessary
- a configuration of the type `esp_idf_svc::mqtt::client::MqttClientConfiguration`
- a handler closure similar to the http server exercise

```rust
const url = format!("mqtt://{}:{}@{}", username, password, host);
let cfg = MqttClientConfiguration::default();
let mut client = EspMqttClient::new_with_callback(url, &cfg, move |message_event| { 
    // ... your handler code here - leave this empty for now
    // we'll add functionality later in this chapter
};
```
## Publish & Subscribe

`EspMqttClient` is also responsible for subscribing to topics and publishing messages under a given topic.
The `publish` function includes a `retain` parameter indicating whether this message should also be delivered to clients that connect after it has been published. 

```rust
let subscribe_topic = /* ... */;
client.subscribe(subscribe_topic, QoS::AtLeastOnce)

let publish_topic = /* ... */;
let payload: &[u8] = /* ... */ ;
client.publish(publish_topic, QoS::AtLeastOnce, false, payload)?;
```

✅ Create an `EspMqttClient` with a default configuration and an empty handler closure.

✅ Send an empty message under the `hello` topic to the broker. Use the `hello_topic(uuid)` utility function to generate a properly scoped topic.

✅ Verify a successful publish by having a client connected that logs these messages. The `example_client` implements this behavior.

✅ In the loop at the end of your main function, publish the board temperature every second. Verify this, too.

## Handling incoming messages


The `message_event` parameter in the handler closure is of type `Option<Result<Event<EspMqttMessage>>>`.
Since we're only interested in processing successfully received messages, we can make use of deep pattern matching:

```rust
if let Some(Ok(Received(message))) = message_event {
    match message.details() {
        Details::Complete(token) => {
            // all messages in this exercise will be of type `Complete`
            // the other variants of the `Details` enum
            // are for larger message payloads

            // Cow<str> behaves a lot like other Rust strings (&str, String)
            let topic: Cow<str> = message.topic(token); 

            // determine if we're interested in this topic and
            // dispatch based on its content
            let is_command_topic: bool = /* ... */;
            if is_command_topic {
                let raw = RawCommandData { /* ... */ };
                if let Ok(Command::BoardLed(color)) = Command::try_from(raw) {
                    // set the LED to the newly received color
                }
            
            },
        _ => {}
        }
    }
}
```

✅ Subscribe to all "command" messages, combining `cmd_topic_fragment(uuid)` with a trailing `#` wildcard

✅ Verify your subscription is working by logging the received topic and running the `example_client` in parallel. You should receive a board LED command roughly every second.

✅ React to the LED commands by setting the newly received color

## Hints

- `split()` on a string returns an iterator. You can access a specific item from an iterator using [`nth()`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.nth).
- TODO more hints here

## Extra tasks

- leverage [`serde_json`](https://docs.serde.rs/serde_json/) to encode/decode your message data as JSON.
- Send some messages with a large payload from the example client and process them on the microcontroller. Large messages will be delivered in parts instead of `Details::Complete`:
```rust
InitialChunk(chunk_info) => { /* first chunk */},
SubsequentChunk(chunk_data) => { /* all subsequent chunks */ }
```
You do not need to differentiate incoming chunks based on message ID, since at most one message will be in flight at any given time. 

## Troubleshooting

- `error: expected expression, found .` when building example client: update your stable Rust installation to 1.58 or newer
- MQTT messages not showing up? make sure all clients (board and workstation) use the same UUID (you can see it in the log output)

