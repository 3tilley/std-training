# I²C

## Introduction

The Inter-Integrated Circuit protocol (usually shortened to I��²C or I2C) allows multiple peripheral chips to communicate with one or more controller chips. Many devices can be connected to the same I²C bus and messages can be sent to a particular device by specifying its I²C address. The protocol requires two signal wires and can only be used for short-distance communications within one device. 

One of the signal lines is for data (SDA) and the other is for the clock signal (SCL). The lines are pulled-high by default with some resistors fitted somewhere on the bus. Any device on the bus (or even multiple devices simultaneously) can 'pull' either or both of the signal lines low. This means that no damage occurs if two devices try and talk on the bus at the same time - the messages are merely corrupted (and detectably so).

An I²C _transaction_ consists of one or more _messages_. Each _message_ is comprised of a _start symbol_, some _words_, and finally a _stop symbol_ (or another _start symbol_ if there is a follow-on message). Each word is eight bits, followed by an ACK (0) or NACK (1) bit which is sent by the recipient to indicate whether the word was received and understood correctly. The first word indicates both the 7-bit address of the device the message is intended for, plus a bit to indicate if the device is being _read from_ or being _written to_. If there is no device of that address on the bus, the first word will naturally have a 'NACK' after it (because there is no device driving the SDA line low to generate an 'ACK' bit) and so you know there is no device present.

The clock frequency of the SCL line is usually 100 kHz but sometimes faster speeds like 400 kHz (or higher) are supported.

To read three bytes from an EEPROM device, the sequence will be something like:

| Step | Controller Sends         | Peripheral Sends                  |
| ---- | ------------------------ | --------------------------------- |
| 1.   | START                    |                                   |
| 2.   | Device Address + W       |                                   |
| 3.   |                          | ACK                               |
| 4.   | High EEPROM Address byte |                                   |
| 5.   |                          | ACK                               |
| 6.   | Low EEPROM Address byte  |                                   |
| 7.   |                          | ACK                               |
| 8.   | START                    |                                   |
| 9.   | Device Address + R       |                                   |
| 10.  |                          | ACK                               |
| 11.  |                          | Data Byte from EEPROM Address     |
| 12.  | ACK                      |                                   |
| 13.  |                          | Data Byte from EEPROM Address + 1 |
| 14.  | ACK                      |                                   |
| 15.  |                          | Data Byte from EEPROM Address + 2 |
| 16.  | NAK (i.e. end-of-read)   |                                   |
| 17.  | STOP                     |                                   |

TODO I2C signal image
## I2C Driver Exercise

We're not going to write an entire driver, merely the first step: the `hello world` of driver writing: reading the device ID of the sensor. 

TODO `i2c-driver/exercise/src/imc42670p.rs` is a gap text of a very basic I²C IMU sensor driver. The task is to complete the file, so that running `main.rs` will log the device ID of the driver. The this gap text driver is based on the version of the same name that lives in common, but provides a little bit more functionality.

### Driver API

#### Instance of the Sensor

To use a peripheral sensor first you must get an instance of the it. The sensor is represented as a struct that contains both its Device Address, and an object representing the I²C bus itself. This is done using traits defined in the `embedded-hal` crate. The struct is public as it needs to be accessible from outside this crate, but its fields are private. We also implement an instantiating method. Methods can also be public or private. This method needs to be accessible from outside, so it's labelled `pub`. Note that written this way, the sensor instance takes ownership of the I²C bus.

```rust 
#[derive(Debug)]
pub struct IMC42670P<I2C> {
    /// The concrete I²C device implementation.
    i2c: I2C,

    /// Device address
    address: SlaveAddr,
}

// ...

impl<I2C, E>IMC42670P<I2C>
where
    I2C: i2c::WriteRead<Error = E> + i2c::Write<Error = E>,
{
    /// Create a new instance of the IMC42670P.
    pub fn new(i2c: I2C, address: SlaveAddr) -> Result<Self, E> {

        let imc42670p = IMC42670P { i2c, address };

        Ok(imc42670p)
    }
// ...
```

#### Representation of Registers 

The sensor's registers are represented as enums. Each variant has the register's address as value. The type `Register` implements a method that exposes the variant's address.

```Rust 
#[derive(Clone, Copy)]
pub enum Register {
    WhoAmI = 0x75,
}

impl Register {
    fn address(&self) -> u8 {
        *self as u8
    }
}

```

#### read_register() and write_register()

We define a read and a write method, based on methods provided by the `embedded-hal` crate. They serve as helpers for more specific methods and as an abstraction that is adapted to a sensor with 8-bit registers. Note how the `read_register()` method is based on a `write_read()` method. The reason for this lies in the characteristics of the I²C protocol: We first need to write a command over the I²C bus to specify which register we want to read from. Helper methods can remain private as they don't need to be accessible from outside this crate. 

```rust
impl<I2C, E>IMC42670P<I2C>
where
    I2C: i2c::WriteRead<Error = E> + i2c::Write<Error = E>,
{    
    //...
    fn write_register(&mut self, register: Register, value: u8) -> Result<(), E> {
        let byte = value as u8;
        self.i2c
            .write(self.address as u8, &[register.address(), byte])
    }

    fn read_register(&mut self, register: Register) -> Result<u8, E> {
        let mut data = [0];
        self.i2c
            .write_read(self.address as u8, &[register.address()], &mut data)?;
        Ok(u8::from_le_bytes(data))
    }
}
```

✅ Implement a public method that reads the `WHOAMI` register with the address `0x0F`. 
✅ Optional: Implement further methods that add features to the driver. Check the [documentation](https://3cfeqx1hf82y3xcoull08ihx-wpengine.netdna-ssl.com/wp-content/uploads/2021/07/DS-000451-ICM-42670-P-v1.0.pdf) for the respective registers and their addresses. Some ideas:
    * switching the the gyroscope sensor or the accelerometer on
    * starting measurements
    * reading measurements

TODO: Add general info about how registers work

## I2C Sensor Reading Exercise

TODO `i2c-sensor-reading/exercise/src/main.rs` is an exercise skeleton that will build. The task is to use an existing driver from crates.io to read out the temperature and humidity sensor over i2c. After that, a second sensor will be read out over the same i2c bus using `shared-bus`. The driver for the second sensor is available locally in `common/`.

`i2c-sensor-reading/solution/src/main.rs` contains a working solution.


* Define two pins, one as SDA and one as SCL. Use them to instantiate an Instance of the I²C peripheral. 

* Using the existing driver crates, make an instance of each sensor, passing the I²C instance into them. 


TODO `i2c-driver/exercise/src/main.rs` contains working code. Running it without modifying the driver file will yield errors. 

`i2c-driver/solution/src/imc42670p.rs` provides a solution to the task. 






